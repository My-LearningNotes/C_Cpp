函数调用约定(Calling Convention)
================================

当调用函数时，如果函数的参数多于一个，按照什么顺序把参数压入堆栈；函数调用结束后，由谁来把堆栈恢复原样。
在高级语言中，通过函数调用约定来说明这两个问题。
函数调用约定会\ **影响函数参数的入栈方式，栈现场的恢复方式，编译器函数名的修饰规则等**\ 。


几种函数名调用约定
------------------

-  ``__cdecl``

    ``__cdecl``\ 是\ *C Declaration*\ 的缩写，表示C语言默认的函数调用约定: 
        * 所有参数从右到左依次入栈，这些参数由调用者清除，称为\ **手动清栈**\ 。
        * 被调用函数不会要求调用者传递多少参数，调用者传递过多或者过少的参数，甚至完全不同的参数都不会产生编译阶段的错误。

        .. note::

            因为这样的调用约定，C调用约定允许函数的参数个数是不固定的，这也是C语言的一大特色。

-  ``__stdcall``

    ``__stdcall``\ 是Standard Call的缩写，是C++的标准调用方式: 
        所有参数从右到左依次入栈，如果是调用类成员的话，最后一个入栈的是\ ``this``\ 指针。
        这些栈中的参数由被调用的函数在返回后清除，使用的指令是\ ``retnX``, ``X``\ 表示参数占用的字节数，CPU在\ ``ret``\ 之后自动弹出X个字节的栈空间，称为\ **自动清栈**\ 。
        函数在编译的时候就必须确定参数个数，并且调用者必须严格的控制参数的生成，不能多，不能少，否则返回后会出错。

-  ``__fastcall``

    ``__fastcall``\ 调用约定和\ ``__stdcall``\ 类似。
    由于大多数的函数参数个数很少，使用堆栈传递比较费时。因此\ ``__fastcall``\ 通常规定将前两个(或若干个)参数由寄存器传递，其余参数还是通过堆栈传递。
    不同编译器编译的程序规定的寄存器不同，返回方式和\ ``__stdcall``\ 相当。

-  ``__thiscall``

    ``__thiscall``\ 是为了解决类成员调用中\ ``this``\ 指针传递而规定的。
    \ ``__thiscall``\ 要求把\ ``this``\ 指针放在特定的寄存器中，该寄存器由编译器决定。
    VC使用\ ``ecx``\ ，Borland的C++编译器使用\ ``eax``\ 。返回方式和\ ``__stdcall``\ 相当。

.. warning::

   ``__fastcall``\ 和\ ``__thiscall``\ 设计的寄存器由编译器决定，因此不能用作跨编译器的接口。



C编译器函数名称修饰规则
-----------------------

-  ``__stdcall``: 编译后，函数名被修饰为\ ``_functionname@number``

-  ``__cdecl``: 编译后，函数名被修饰为\ ``_functionname``

-  ``__fastcall``: 编译后，函数名被修饰为\ ``@functionname@number``

.. tip::

    -  ``functionname``\ 为函数名，\ ``number``\ 为参数字节数

    -  函数实现和函数定义时如果使用了不同的函数调用约定，则无法实现函数调用


C++编译器函数名称修饰规则
-------------------------

-  ``__stdcall``: 编译后，函数名被修饰为\ ``?funcitonname@@YG******@Z"``

-  ``__cdecl``: 编译后，函数名被修饰为\ ``?functionname@@YA******@Z"``

-  ``__fastcall``: 编译后，函数名被修饰为\ ``?functionname@@YI******@Z``

.. tip::

    -  ``******``\ 为函数返回值类型和参数类型表

    -  函数实现和函数定义时如果使用了不同的函数调用约定，则无法实现函数调用

    -  C和C++之间如果不进行特殊处理，也无法实现函数的相互调用

